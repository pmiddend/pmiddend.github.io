<!DOCTYPE html>
<html lang="en-us">
<head>
    <title>An alternative to Optional - nullable composition - org-page</title>
    <meta charset="utf-8" />
    <meta name="author" content="Philipp Middendorf" />
        <meta name="description" content="" />
        <meta name="keywords" content="java, fp" />
    <link rel="stylesheet" href="/media/css/style.css">
    <link rel="stylesheet" href="/media/css/highlight.css">
    <style type="text/css"></style>
</head>

  <body class="container">
    <nav class="main-nav">
        <a href="/blog">Archive</a>
        <a href="/tags">Tag</a>
        <a href="/about/">About</a>
        <a class="cta" href="https://github.com/pmiddend">GitHub</a>
    </nav>

<div>
    <section id="wrapper">
        <article class="post">
            <header>
                    <h1>An alternative to Optional - nullable composition</h1>
            </header>
            <br />
            <section id="post-body">
                <div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6">An alternative to optional - nullable composition</h2>
<div class="outline-text-2" id="text-orgheadline6">
</div><div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1">Prerequisite and disclaimer</h3>
<div class="outline-text-3" id="text-orgheadline1">
<p>
In order to understand this post, you have to be familiar with <b>lambdas</b>, <b>default methods</b>, <b>functional interfaces</b> and ideally <code>Optional</code>. Also, please read this post more as a brain teaser than something to live by. I'm not advocating ditching <code>null</code>, <code>Optional</code> or using the functions below everywhere. It's an exercise in thinking functionally, above all.
</p>

<p>
Also, what I describe is probably some bastardized version of a simple concept that the Haskell people use on a regular basis. If so, please tell me, I'm eager to put all of this in context.
</p>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">Prelude: Booooo! <code>null</code>!</h3>
<div class="outline-text-3" id="text-orgheadline2">
<p>
Since day one, Java has had <code>null</code> as a special value that inhabits every type deriving from <code>Object</code>. In this article, I won't go into detail over why that's <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">widely considered a bad idea</a>. It's in the language an we have to deal with it properly. Typical code handling <code>null</code> values looks like this:
</p>

<div class="org-src-container">

<pre class="src src-java">public void printMaleTenantsSpouse(Apartment a) {
 if(a != null) {
   Person t = a.getTenant();
   if(t != null) {
     if(t.isMale()) {
       Person spouse = t.getSpouse();
       if(spouse != null) {
         System.out.println(spouse.getName());
       }
     }
   }
 }
}
</pre>
</div>

<p>
Here, I am assuming that <i>every</i> value in the object tree might be <code>null</code>, which mostly makes sense. An apartment doesn't have to have a tenant; that tenant doesn't have to have a spouse, and so on. Because we have to test for <code>null</code> on every level, this leads to some deeply nested code. I also threw in some other <code>if</code> just for kicks.
</p>
</div>
</div>
<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">The savior, <code>Optional</code>!</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
In Java 8 though, there's <code>Optional</code>. This type and its operations were borrowed from languages like <a href="https://hackage.haskell.org/package/base/docs/Data-Maybe.html">Haskell</a> and <a href="http://en.cppreference.com/w/cpp/utility/optional/optional">C++</a>, where you're in the opposite position: nothing can be null unless you wrap it in an optional type. It exposes the following <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">operations</a> (slightly simplified for readability):
</p>

<ul class="org-ul">
<li><code>Optional&lt;T&gt; empty()</code>: creates an empty <code>Optional</code>.</li>
<li><code>Optional&lt;T&gt; of(T t)</code>: creates a non-empty <code>Optional</code> from a non-null value (throws if <code>null</code> is passed).</li>
<li><code>Optional&lt;T&gt; ofNullable(T t)</code>: creates an empty <code>Optional</code> if passed <code>null</code>, otherwise a non-empty <code>Optional</code>.</li>
<li><code>T get()</code>: returns the value inside the optional, throwing if it's empty.</li>
<li><code>boolean isPresent()</code>: returns <code>true</code> if the optional is non-empty.</li>
<li><code>T orElse(T t)</code>: returns <code>t</code> if the <code>Optional</code> is empty, otherwise returns the value inside the <code>Optional</code>.</li>
<li><code>T orElseGet(Supplier&lt;T&gt; f)</code>: returns the result of applying <code>f</code> if the <code>Optional</code> is empty, otherwise returns the value inside the <code>Optional</code>.</li>
<li><code>T orElseThrow(Supplier&lt;Throwable&gt; f)</code>: throws if empty, otherwise returns the value inside the <code>Optional</code>.</li>
<li><code>void ifPresent(Consumer&lt;T&gt; f)</code>: executes <code>f</code>, passing the value if it's non-empty; otherwise does nothing.</li>
<li><code>Optional&lt;T&gt; filter(Predicate&lt;T&gt; p)</code>: checks the value inside the <code>Optional</code> against the predicate and maybe empties (literally) the optional accordingly.</li>
<li><code>Optional&lt;U&gt; map(Function&lt;T,U&gt; f)</code>: leaves empty <code>Optionals</code> empty, otherwise executes <code>f</code> on the value.</li>
<li><code>Optional&lt;U&gt; flatMap(Function&lt;T,Optional&lt;U&gt;&gt; f)</code>: leaves empty <code>Optionals</code> empty (switching the types), applies <code>f</code> to non-empty <code>Optionals</code> and returns the result.</li>
</ul>

<p>
Assuming we litter our data structures with getters that return <code>Optional</code> instead of <code>null</code> and using Java 8's method references, the code above could be written as follows:
</p>

<div class="org-src-container">

<pre class="src src-java">public void printMaleTenantsSpouse(Optional&lt;Apartment&gt; a) {
  a.flatMap(Apartment::getTenant)
   .filter(Person::isMale)
   .flatMap(Person::getSpouse)
   .map(Person::getName)
   .ifPresent(System.out::println);
}
</pre>
</div>

<p>
This is slightly shorter and looks cleaner, because the code doesn't expand to the right, and we don't have to assign any names which we only use once.
</p>

<p>
Great, now what's the problem? Well, we're actually misusing <code>Optional</code>! As <code>Optional</code>'s creator Stuart Marks often notes (for example in <a href="http://stackoverflow.com/questions/23454952/uses-for-java8-optional/23464794#23464794">this StackOverflow answer</a>), there are some "intended" uses for <code>Optional</code>, such as the return type of functions so you can "continue a chain of fluent method calls", which is actually one of the main reason why <code>Optional</code> was introduced -- to make chained calls with <code>Stream</code> operations prettier:
</p>

<div class="org-src-container">

<pre class="src src-java">collection.stream()
          .map(f)
          .filter(p)
          // findFirst returns the first found value in the stream 
          // as an Optional&lt;T&gt; (the stream could be empty)
          .findFirst()
          .map(f2)
          .orElse(x);
</pre>
</div>

<p>
However, using <code>Optional</code> as a parameter to a function (as seen above) or as a field of a data structure is "considered misuse", and many articles have been written about that fact (pro and contra). Also, <code>Optional</code> deliberately does not extend <code>Serializable</code> and framework support to serialize to JSON, for example, might have to to be enabled explicitly.
</p>

<p>
Also, from a more idealistic perspective, why have another type that represents the absence of a value? As we discovered, every variable can already be absent, containing <code>null</code>. What we're doing with <code>Optional</code> is wrapping it in another layer and unwrapping it at the end.
</p>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">Burn <code>Optional</code>, hooray for <code>null</code>!</h3>
<div class="outline-text-3" id="text-orgheadline4">
<p>
If we want this functional style operations, can't we define them on nullable types instead? Let's quickly go through the operations and how we might adapt them to work on plain types <code>T</code> that might contain <code>null</code>:
</p>

<ul class="org-ul">
<li><code>empty()</code>: we don't need a function for that, just write <code>null</code> and you're done!</li>
<li><code>of(t)</code>: this is also just packaging we don't need</li>
<li><code>ofNullable(t)</code>: see above</li>
<li><code>get()</code>: See above; just use the nullable value like you normally would; you'll get a <code>NullPointerException</code> if it's empty.</li>
<li><p>
<code>isPresent()</code>: this is just an if statement:
</p>
<div class="org-src-container">

<pre class="src src-java">public &lt;T&gt; boolean isPresent(T t) {
  return t != null;
}
</pre>
</div></li>
<li><p>
<code>orElse(t)</code>: another if:
</p>
<div class="org-src-container">

<pre class="src src-java">public &lt;T&gt; boolean orElse(T t,T u) {
  return t != null ? t : Objects.requireNonNull(u);
}
</pre>
</div></li>
<li><p>
<code>orElseGet(t)</code>: an if with a <code>get</code>:
</p>
<div class="org-src-container">

<pre class="src src-java">public &lt;T&gt; boolean orElseGet(T t,Supplier&lt;T&gt; f) {
  return t != null ? t : Objecs.requireNonNull(f.get());
}
</pre>
</div></li>
<li><p>
<code>orElseThrow(t)</code>: an if with a throw:
</p>
<div class="org-src-container">

<pre class="src src-java">public &lt;T&gt; boolean orElseThrow(T t,Supplier&lt;Throwable&gt; f) {
  if(t == null)
    throw f.get();
  return t;
}
</pre>
</div></li>
<li><p>
<code>ifPresent(f)</code>: slightly more interesting:
</p>
<div class="org-src-container">

<pre class="src src-java">public &lt;T&gt; void ifPresent(T t,Consumer&lt;T&gt; f) {
  if(t != null)
    f.accept(t);
}
</pre>
</div></li>
<li><p>
<code>filter(p)</code>: given <code>null</code> (previously an empty <code>Optional</code>), just return <code>null</code>. Given non-null, return <code>null</code> if the predicate doesn't match, otherwise return the given value:
</p>
<div class="org-src-container">

<pre class="src src-java">public static &lt;T&gt; T filter(T t,Predicate&lt;T&gt; p) {
  return t == null || !p.test(t) ? null : t;
}
</pre>
</div></li>
<li><p>
<code>map(f)</code>: does nothing if passed <code>null</code>, otherwise applies the function (which returns a <code>U</code>, not another <code>Optional</code>, so we have to be sure that it doesn't return <code>null</code>!)
</p>
<div class="org-src-container">

<pre class="src src-java">public static &lt;T,U&gt; T map(T t,Function&lt;T,U&gt; f) {
  if (t == null)
    return null;
  return Objects.requireNonNull(f.apply(t));
}
</pre>
</div></li>
<li><p>
<code>flatMap(f)</code>: strikingly similar to <code>map</code>, but without the null check - the given function is allowed to return another <code>Optional</code> (or <code>null</code> in our case):
</p>
<div class="org-src-container">

<pre class="src src-java">public static &lt;T,U&gt; T flatMap(T t,Function&lt;T,U&gt; f) {
  if (t == null)
    return null;
  return f.apply(t);
}
</pre>
</div></li>
</ul>

<p>
Using these operations, we can indeed rewrite the code as such:
</p>

<div class="org-src-container">

<pre class="src src-java">ifPresent(
  map(
    flatMap(
      filter(
        flatMap(
          a,
          Apartment::getTenant),
        Person::isMale),
      Person::getSpouse),
    Person::getName),
  System.out::println)
</pre>
</div>

<p>
Beautiful, isn't it! Such functional, very monadic!
</p>

<p>
So there's a reason Haskell has support for defining custom operators and an even more special syntax for <code>flatMap</code> operations, and Java has these chained method calls: functional code looks pretty ugly without them!
</p>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">Burn <code>Optional</code> <i>and</i> <code>null</code>, use functions!</h3>
<div class="outline-text-3" id="text-orgheadline5">
<p>
But we don't have to abandon ship just yet. What both the <code>Optional</code> code and the ugly-as-hell monster code above <i>did</i> hide is the conditional code, the "glue code" between our functions <code>Apartment::getTenant</code>, <code>Person::getName</code> and so on. Can't we concatenate these functions in a chained style, without using <code>Optional</code>, but hiding away the <code>if-else</code>?
</p>

<p>
What if instead of wrapping the <i>value</i>, we wrap the <i>function</i>? Instead of looking at a <i>value</i> that can be <code>null</code>, we're now looking at a <i>function</i> that can <i>return</i> <code>null</code>. In pseudocode with an annotation to remind you:
</p>

<div class="org-src-container">

<pre class="src src-java">@FunctionalInterface
interface NullableFunction&lt;T,U&gt; {
  @Nullable
  U apply(@Nonnull T t);

  static &lt;A,B&gt; NullableFunction&lt;A,B&gt; of(NullableFunction&lt;A,B&gt; f) {
    return f;
  }
}
</pre>
</div>

<p>
The function <code>of()</code> is necessary to force the type system to create the <code>NullableFunction</code> out of a method reference. I won't go into it here, so if you're not sure what it does, please read about <code>@FunctionalInterface</code>.
</p>

<p>
Now, assuming we have such a <code>NullableFunction</code>, we want to compose that with another function that returns <code>null</code>, thus defining the equivalent of <code>flatMap</code>:
</p>

<div class="org-src-container">

<pre class="src src-java">interface NullableFunction&lt;T,U&gt; {
  // ...

  default &lt;R&gt; NullableFunction&lt;T,R&gt; flatMap(NullableFunction&lt;U,R&gt; f) {
    return t -&gt; {
      U u = this.apply(t);
      if(u == null)
        return null;
      return f.apply(u);
    };
  }
}
</pre>
</div>

<p>
Since we introduced a <code>null</code>-based <code>flatMap</code> before, this code is easy (we could even re-use the code from above, but I chose to expose it again). <code>filter</code> is a little tricky, because we have two choices: we can filter the argument of the function and the result (which can be null, of course). So I've provided both:
</p>

<div class="org-src-container">

<pre class="src src-java">interface NullableFunction&lt;T,U&gt; {
  // ...
  default NullableFunction&lt;T,U&gt; filterArgument(Predicate&lt;T&gt; p) {
    return t -&gt; {
      return p.test(t) ? this.apply(t) : null;
    };
  }

  default NullableFunction&lt;T,U&gt; filterResult(Predicate&lt;U&gt; p) {
    return t -&gt; {
      U u = this.apply(t);
      if(u == null || !p.test(u))
        return null;
      return u;
    };
  }
}
</pre>
</div>

<p>
The function <code>map</code>, is interesting, because it requires a function that does <i>not</i> return <code>null</code>. So we can't pass another <code>NullableFunction</code>. We could invent another interface <code>NonnullFunction</code>, but I've decided to just take <code>java.util.Function</code>:
</p>

<div class="org-src-container">

<pre class="src src-java">interface NullableFunction&lt;T,U&gt; {
  // ...
  default NullableFunction&lt;T,R&gt; map(Function&lt;U,R&gt; p) {
    return t -&gt; {
      U u = this.apply(t);
      if(u == null)
        return null;
      return p.apply(u);
    };
  }
}
</pre>
</div>

<p>
The <code>orElse</code> family of functions can be defined, too:
</p>

<div class="org-src-container">

<pre class="src src-java">interface NullableFunction&lt;T,U&gt; {
  // ...

  default NullableFunction&lt;T,U&gt; orElse(U fallback) {
    return t -&gt; {
      U u = this.apply(t);
      return u == null ? fallback : u;
    };
  }

  default NullableFunction&lt;T,U&gt; orElseGet(Supplier&lt;U&gt; fallback) {
    return t -&gt; {
      U u = this.apply(t);
      return u == null ? fallback.get() : u;
    };
  }

  // I am deliberately ignoring the fact that lambdas cannot 
  // throw in Java.
  default NullableFunction&lt;T,U&gt; orElseThrow(Supplier&lt;U&gt; thrower) {
    return t -&gt; {
      U u = this.apply(t);
      if(u == null)
        throw thrower.get();
      return u;
    };
  }
}
</pre>
</div>

<p>
The function <code>ifPresent</code> can be defined. In <code>Optional</code>, it returns <code>void</code>, but it's much more usable as an equivalent of the <code>Stream</code> function <code>peek</code>, so you can continue chaining:
</p>

<div class="org-src-container">

<pre class="src src-java">interface NullableFunction&lt;T,U&gt; {
  // ...

  default NullableFunction&lt;T,U&gt; ifPresent(Consumer&lt;U&gt; presenter) {
    return t -&gt; {
      U u = this.apply(t);
      if(u != null)
        presenter.accept(u);
      return u;
    };
  }
}
</pre>
</div>

<p>
There are some functions that cannot be transferred from <code>Optional: =get</code> doesn't make sense, because we have a function, not a value. There's nothing in it to get, it's the "between the values". <code>of</code> and <code>ofNullable</code> you cannot meaningfully define, because they refer to a single value, not a transformation. You <i>could</i> define <code>constant</code>, the function that, given any argument, ignores it and always returns a certain <code>t</code>:
</p>

<div class="org-src-container">

<pre class="src src-java">interface NullableFunction&lt;T,U&gt; {
  // ...

  static NullableFunction&lt;T,U&gt; constant(U u) {
    return ignoreThisArgument -&gt; {
      return u;
    };
  }
}
</pre>
</div>

<p>
With this new machinery, let's rewrite the initial example again:
</p>

<div class="org-src-container">

<pre class="src src-java">NullableFunction.of(Apartment::getTenant)
                .filterResult(Person::isMale)
                .flatMap(Person::getSpouse)
                .map(Person::getName)
                .ifPresent(System.out::println)
                .apply(a);
</pre>
</div>

<p>
This looks as clean as the <code>Optional</code> solution, but doesn't extend to the right like the other solution without it. It is, however, not quite correct: We said that the <code>Apartment</code> we pass into it might be <code>null</code>, too. In the chaining methods we assumed that the value we pass is non-null (the <i>result</i>, however, can be null). To mitigate this, we add another convenience function <code>applyNullable</code> to <code>NullableFunction</code>:
</p>

<div class="org-src-container">

<pre class="src src-java">interface NullableFunction&lt;T,U&gt; {
  // ...

  default U applyNullable(T t) {
    return t != null ? this.apply(t) : null;
  }
}
</pre>
</div>

<p>
So the chain becomes:
</p>

<div class="org-src-container">

<pre class="src src-java">NullableFunction.of(Apartment::getTenant)
                .filterResult(Person::isMale)
                .flatMap(Person::getSpouse)
                .map(Person::getName)
                .ifPresent(System.out::println)
                .applyNullable(a);
</pre>
</div>

<p>
That's it folks. If you have questions or comments, please leave them in the according reddit thread in <code>/r/java</code>.
</p>
</div>
</div>
</div>

            </section>
    </section>
</div>

    <div>
    <section id="wrapper">
      <div class="post-meta">
        <span title="post date" class="post-info">2016-06-18</span>
        <span title="tags" class="post-info"><a href="/tags/java/">java</a>, <a href="/tags/fp/">fp</a></span>
      </div>
      <br />
      <br />
      <section>
        <h1>Comments</h1>
      </section>
      <script src="http://code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-65636503-1']);
        _gaq.push(['_trackPageview']);
        (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      </script>
      <div align="center">
      <footer id="footer">
        <p class="small">
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:pmidden &lt;at&gt; secure &lt;dot&gt; mailbox &lt;dot&gt; org">Philipp Middendorf</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
        <br />
      </footer>
      </div>
      </section>
    </div>

  </body>
</html>
